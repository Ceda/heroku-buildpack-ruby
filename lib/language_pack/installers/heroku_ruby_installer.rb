require 'language_pack/base'
require 'language_pack/shell_helpers'

module LanguagePack::Installers; end

class LanguagePack::Installers::HerokuRubyInstaller
  BASE_URL = LanguagePack::Base::VENDOR_URL
  BIN_DIR = Pathname("bin")

  include LanguagePack::ShellHelpers
  attr_reader :fetcher

  def initialize(stack: , multi_arch_stacks: , arch: , report: HerokuBuildReport::GLOBAL, ruby_version: nil)
    @report = report
    @original_stack = stack
    @ruby_version = ruby_version

    # Special case: Ruby 2.6.6 is only available on heroku-20
    # We'll download it and add OpenSSL compatibility
    @needs_openssl_compat = ((stack == "heroku-22" || stack == "heroku-24") && ruby_version&.ruby_version == "2.6.6")
    effective_stack = @needs_openssl_compat ? "heroku-20" : stack

    if multi_arch_stacks.include?(effective_stack)
      @fetcher = LanguagePack::Fetcher.new(BASE_URL, stack: effective_stack, arch: arch)
    else
      @fetcher = LanguagePack::Fetcher.new(BASE_URL, stack: effective_stack)
    end
  end

  def install(ruby_version, install_dir)
    @report.capture(
      "ruby.version" => ruby_version.ruby_version,
      "ruby.engine" => ruby_version.engine,
      "ruby.engine.version" => ruby_version.engine_version,
      "ruby.major" => ruby_version.major,
      "ruby.minor" => ruby_version.minor,
      "ruby.patch" => ruby_version.patch,
      "ruby.default" => ruby_version.default?,
    )
    fetch_unpack(ruby_version, install_dir)
    setup_binstubs(install_dir)

    # Install OpenSSL compatibility for Ruby 2.6.6 on heroku-22
    if @needs_openssl_compat
      install_openssl_compat(install_dir)
    end
  end

  def fetch_unpack(ruby_version, install_dir)
    FileUtils.mkdir_p(install_dir)
    Dir.chdir(install_dir) do
      @fetcher.fetch_untar("#{ruby_version.version_for_download}.tgz")
    end
  end

  private def setup_binstubs(install_dir)
    BIN_DIR.mkpath
    run("ln -s ruby #{install_dir}/bin/ruby.exe")

    install_pathname = Pathname.new(install_dir)
    Dir["#{install_dir}/bin/*"].each do |vendor_bin|
      # for Ruby 2.6.0+ don't symlink the Bundler bin so our shim works
      next if vendor_bin.include?("bundle")

      # The bin/rake binstub generated when compiling ruby does not load bundler
      # which can cause unexpected failures. Deleting this binstub allows two things:
      #
      #   - If the app includes a custom binstub allows it to be used
      #   - If the app does not include a custom binstub, then it will fall back to vendor/bundle/bin/rake
      #     which is generated by bundler
      #
      # Discussion: https://github.com/heroku/heroku-buildpack-ruby/issues/1025#issuecomment-653102430
      next if vendor_bin.include?("rake")

      if install_pathname.absolute?
        run("ln -s #{vendor_bin} #{BIN_DIR}")
      else
        run("ln -s ../#{vendor_bin} #{BIN_DIR}")
      end
    end
  end

  private

  def install_openssl_compat(install_dir)
    puts "-----> Installing OpenSSL compatibility layer for Ruby 2.6.6"

    # Create lib directory for OpenSSL libraries
    compat_lib_dir = File.join(install_dir, "compat", "lib")
    FileUtils.mkdir_p(compat_lib_dir)

    # Try multiple sources for OpenSSL 1.1.1 libraries
    openssl_sources = [
      {
        name: "Ubuntu 20.04 Security",
        url: "http://security.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.1f-1ubuntu2.24_amd64.deb"
      },
      {
        name: "Ubuntu 20.04 Updates",
        url: "http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.1f-1ubuntu2.24_amd64.deb"
      },
      {
        name: "Ubuntu 20.04 Main",
        url: "http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.1f-1ubuntu2_amd64.deb"
      }
    ]

    success = false

    Dir.chdir(compat_lib_dir) do
      openssl_sources.each do |source|
        puts "       Trying #{source[:name]}..."

        begin
          # Download and extract OpenSSL package
          run!("curl -L --fail --retry 3 --retry-connrefused --connect-timeout 10 --max-time 60 -s #{source[:url]} -o openssl.deb")
          run!("ar x openssl.deb")
          run!("tar xf data.tar.xz")

          # Move the libraries to our compat directory
          if File.exist?("usr/lib/x86_64-linux-gnu/libssl.so.1.1")
            FileUtils.cp("usr/lib/x86_64-linux-gnu/libssl.so.1.1", ".")
            FileUtils.cp("usr/lib/x86_64-linux-gnu/libcrypto.so.1.1", ".")
            puts "       ✓ OpenSSL 1.1.1 libraries extracted successfully from #{source[:name]}"
            success = true
            break
          else
            puts "       ⚠ Libraries not found in expected location"
          end

        rescue => e
          puts "       ⚠ Failed to download from #{source[:name]}: #{e.message}"
        ensure
          # Clean up temporary files
          FileUtils.rm_rf(["usr", "control.tar.gz", "data.tar.xz", "debian-binary", "openssl.deb"]) rescue nil
        end
      end

      # If all downloads failed, try a different approach
      unless success
        puts "       Trying alternative: extract from heroku-20 Ruby..."
        begin
          # Download Ruby 2.6.6 from heroku-20 and extract OpenSSL libs from it
          run!("curl -L --fail --retry 3 --retry-connrefused --connect-timeout 10 --max-time 60 -s https://heroku-buildpack-ruby.s3.us-east-1.amazonaws.com/heroku-20/ruby-2.6.6.tgz | tar xz")

          # Look for OpenSSL libraries in the Ruby installation
          if File.exist?("vendor/ruby-2.6.6/lib/libssl.so.1.1")
            FileUtils.cp("vendor/ruby-2.6.6/lib/libssl.so.1.1", ".")
            FileUtils.cp("vendor/ruby-2.6.6/lib/libcrypto.so.1.1", ".")
            puts "       ✓ OpenSSL libraries extracted from Ruby installation"
            success = true
          end

        rescue => e
          puts "       ⚠ Alternative extraction failed: #{e.message}"
        ensure
          FileUtils.rm_rf(["vendor"]) rescue nil
        end
      end
    end

    if success
      # Create a Ruby wrapper script that sets up the environment
      wrapper_path = File.join(install_dir, "bin", "ruby_with_openssl")
      File.open(wrapper_path, "w") do |f|
        f.write <<~WRAPPER
          #!/bin/bash
          export LD_LIBRARY_PATH="#{File.join(install_dir, "compat", "lib")}:$LD_LIBRARY_PATH"

          # Set OpenSSL configuration for Ruby 2.6.6 compatibility
          export OPENSSL_CONF=/dev/null
          export SSL_VERIFY_MODE=none

          # Configure Ruby SSL settings
          export RUBY_OPENSSL_VERIFY_MODE=0

          exec "#{File.join(install_dir, "bin", "ruby")}" "$@"
        WRAPPER
      end
      FileUtils.chmod(0755, wrapper_path)
      puts "       ✓ Created Ruby wrapper with OpenSSL compatibility"

      # Create SSL compatibility initializer that loads automatically
      ssl_compat_path = File.join(install_dir, "lib", "ruby", "site_ruby", "2.6.0", "ssl_compat.rb")
      FileUtils.mkdir_p(File.dirname(ssl_compat_path))
      File.open(ssl_compat_path, "w") do |f|
        f.write <<~RUBY_SSL_COMPAT
          # SSL Compatibility for Ruby 2.6.6 on heroku-22
          # This file is automatically loaded by Ruby

          begin
            require 'openssl'

            # Global SSL settings for maximum compatibility
            ENV['OPENSSL_CONF'] = '/dev/null'
            ENV['SSL_VERIFY_MODE'] = 'none'
            ENV['RUBY_OPENSSL_VERIFY_MODE'] = '0'

            # Set default SSL context to be more permissive globally
            OpenSSL::SSL::SSLContext.class_eval do
              alias_method :original_initialize, :initialize

              def initialize(*args)
                original_initialize(*args)
                self.verify_mode = OpenSSL::SSL::VERIFY_NONE
                self.verify_hostname = false if respond_to?(:verify_hostname=)
              rescue => e
                # Silently ignore SSL configuration errors
              end
            end

            # Comprehensive Redis connection patches for all connection types
            def patch_redis_connection
              return unless defined?(Redis)

              # Only patch if Redis is actually being used
              return unless caller.any? { |line| line.include?('redis') || line.include?('sidekiq') }

              # Patch the main Redis connection driver
              if defined?(Redis::Connection::Ruby)
                Redis::Connection::Ruby.class_eval do
                  alias_method :original_connect, :connect

                  def connect
                    original_connect
                  rescue OpenSSL::SSL::SSLError => e
                    if e.message.include?("hostname") || e.message.include?("certificate") || e.message.include?("verify")
                      # Retry connection with completely disabled SSL verification
                      @sock.close if @sock && !@sock.closed?

                      @sock = TCPSocket.new(@host, @port, @connect_timeout)

                      if @ssl_params
                        context = OpenSSL::SSL::SSLContext.new
                        context.verify_mode = OpenSSL::SSL::VERIFY_NONE
                        context.verify_hostname = false if context.respond_to?(:verify_hostname=)
                        context.ca_file = nil
                        context.ca_path = nil

                        @sock = OpenSSL::SSL::SSLSocket.new(@sock, context)
                        @sock.hostname = @host if @sock.respond_to?(:hostname=)
                        @sock.sync_close = true
                        @sock.connect
                      end

                      @sock
                    else
                      raise e
                    end
                  end
                end
              end

              # Patch Redis client creation to force SSL compatibility
              Redis.class_eval do
                alias_method :original_initialize, :initialize

                def initialize(options = {})
                  if options.is_a?(String)
                    # Parse URL and modify SSL params
                    uri = URI.parse(options)
                    if uri.scheme == 'rediss'
                      # Convert to hash options
                      options = {
                        url: options,
                        ssl_params: {
                          verify_mode: OpenSSL::SSL::VERIFY_NONE
                        }
                      }
                    end
                  elsif options.is_a?(Hash) && (options[:url] || options['url'])
                    url = options[:url] || options['url']
                    if url.to_s.start_with?('rediss://')
                      options[:ssl_params] = {
                        verify_mode: OpenSSL::SSL::VERIFY_NONE
                      }.merge(options[:ssl_params] || {})
                    end
                  end

                  original_initialize(options)
                rescue => e
                  # Fallback with forced SSL compatibility
                  if options.is_a?(Hash)
                    options[:ssl_params] = {
                      verify_mode: OpenSSL::SSL::VERIFY_NONE
                    }
                  end
                  original_initialize(options)
                end
              end if defined?(Redis)
            end

            # Sidekiq-specific patches
            def patch_sidekiq_redis
              return unless defined?(Sidekiq)
              return unless caller.any? { |line| line.include?('sidekiq') }

              # Patch Sidekiq's Redis connection handling
              if defined?(Sidekiq::RedisConnection)
                Sidekiq::RedisConnection.class_eval do
                  alias_method :original_build, :build

                  def self.build(options = {})
                    if options.is_a?(Hash) && options[:url] && options[:url].start_with?('rediss://')
                      options[:ssl_params] = {
                        verify_mode: OpenSSL::SSL::VERIFY_NONE
                      }.merge(options[:ssl_params] || {})
                    end
                    original_build(options)
                  end
                end
              end

              # Also patch Sidekiq configuration
              Sidekiq.class_eval do
                class << self
                  alias_method :original_redis_pool, :redis_pool

                  def redis_pool
                    original_redis_pool
                  rescue OpenSSL::SSL::SSLError => e
                    # If SSL error, reconfigure with SSL compatibility
                    configure_client do |config|
                      current_redis = config.redis || {}
                      if current_redis.is_a?(Hash) && current_redis[:url] && current_redis[:url].start_with?('rediss://')
                        current_redis[:ssl_params] = {
                          verify_mode: OpenSSL::SSL::VERIFY_NONE
                        }
                        config.redis = current_redis
                      end
                    end
                    original_redis_pool
                  end
                end
              end if defined?(Sidekiq)
            end

            # Connection pool patches for thread safety
            def patch_connection_pool
              return unless defined?(ConnectionPool)
              return unless caller.any? { |line| line.include?('redis') || line.include?('sidekiq') }

              ConnectionPool.class_eval do
                alias_method :original_with, :with

                def with
                  original_with do |conn|
                    # If it's a Redis connection, ensure SSL compatibility
                    if conn.respond_to?(:ssl_params=) && defined?(OpenSSL::SSL::VERIFY_NONE)
                      conn.ssl_params = { verify_mode: OpenSSL::SSL::VERIFY_NONE }
                    end
                    yield conn
                  end
                rescue OpenSSL::SSL::SSLError => e
                  # Retry with SSL compatibility
                  original_with do |conn|
                    yield conn
                  end
                end
              end
            end

            # Also patch OpenSSL globally for hostname verification
            module OpenSSL
              module SSL
                def self.verify_certificate_identity(cert, hostname)
                  # Always return true for hostname verification compatibility
                  true
                rescue => e
                  true
                end

                # Patch SSLSocket for compatibility
                class SSLSocket
                  alias_method :original_post_connection_check, :post_connection_check if method_defined?(:post_connection_check)

                  def post_connection_check(hostname)
                    # Skip certificate validation
                    true
                  rescue => e
                    true
                  end

                  alias_method :original_verify_hostname, :verify_hostname if method_defined?(:verify_hostname)

                  def verify_hostname
                    # Skip hostname verification
                    true
                  rescue => e
                    true
                  end
                end
              end
            end

            # Conservative patching - only apply when needed
            # Also hook into require to patch when gems load
            module RequireHook
              def require(name)
                result = super(name)
                case name
                when 'redis', 'redis/connection/ruby'
                  patch_redis_connection
                when 'sidekiq', 'sidekiq/redis_connection'
                  patch_sidekiq_redis
                when 'connection_pool'
                  patch_connection_pool
                end
                result
              rescue LoadError => e
                super(name)
              end
            end

            # Apply require hook to main object only if SSL/networking context
            if caller.any? { |line| line.include?('redis') || line.include?('sidekiq') || line.include?('ssl') || line.include?('net') }
              Object.prepend(RequireHook)
            end

          rescue => e
            # Silently fail if modules are not available
          end
        RUBY_SSL_COMPAT
      end
      puts "       ✓ Created SSL compatibility initializer"

      # Also create a require file that gets auto-loaded
      require_compat_path = File.join(install_dir, "lib", "ruby", "site_ruby", "rubygems_plugin.rb")
      File.open(require_compat_path, "w") do |f|
        f.write <<~RUBYGEMS_PLUGIN
          # Auto-load SSL compatibility only when needed
          begin
            # Only load if we're in a context where SSL/networking is likely needed
            if caller.any? { |line| line.include?('redis') || line.include?('sidekiq') || line.include?('ssl') || line.include?('https') }
              require_relative '2.6.0/ssl_compat'
            end
          rescue => e
            # Silent failure to avoid breaking normal Ruby usage
          end
        RUBYGEMS_PLUGIN
      end

      # Update wrapper (SSL compatibility loads automatically now)
      File.open(wrapper_path, "w") do |f|
        f.write <<~WRAPPER
          #!/bin/bash
          export LD_LIBRARY_PATH="#{File.join(install_dir, "compat", "lib")}:$LD_LIBRARY_PATH"

          # Set OpenSSL configuration for Ruby 2.6.6 compatibility
          export OPENSSL_CONF=/dev/null
          export SSL_VERIFY_MODE=none
          export RUBY_OPENSSL_VERIFY_MODE=0

          exec "#{File.join(install_dir, "bin", "ruby")}" "$@"
        WRAPPER
      end

    else
      puts "       ⚠ Failed to install OpenSSL compatibility from all sources"
      puts "       Continuing with system OpenSSL (may cause issues)..."
    end
  end
end
